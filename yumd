#!/usr/bin/python -tt
#
# Proof of concept yumd implementation
#
# since it takes me time everytime to figure this out again, here's how to
# queue a check with dbus-send.  adjust appropriately for other methods
# $ dbus-send --system --print-reply --type=method_call \
#   --dest=edu.duke.linux.yum /Updatesd edu.duke.linux.yum.CheckNow

import os, sys
import syslog
import subprocess
import time

from optparse import OptionParser

import dbus
import dbus.service
import dbus.glib
import gobject

import yumdconfig

updateInfoDone = False
updateInfo = []
helperProcess = None

class YumDbusListener(dbus.service.Object):
    def __init__(self, bus_name, object_path='/Updatesd',
                 allowshutdown = False):
        dbus.service.Object.__init__(self, bus_name, object_path)
        self.allowshutdown = allowshutdown

    def doCheck(self):
        checkUpdates()
        return False

    @dbus.service.method("edu.duke.linux.yum", in_signature="")
    def CheckNow(self):
        # make updating checking asynchronous since we discover whether
        # or not there are updates via a callback signal anyway
        gobject.idle_add(self.doCheck)
        return "check queued"

    @dbus.service.method("edu.duke.linux.yum", in_signature="")
    def ShutDown(self):
        if not self.allowshutdown:
            return False
        
        # we have to do this in a callback so that it doesn't get
        # sent back to the caller
        gobject.idle_add(shutDown)
        return True

    @dbus.service.method("edu.duke.linux.yum", in_signature="", out_signature="a(a{ss}a{ss})")
    def GetUpdateInfo(self):
        # FIXME: this call is deprecated.  things should watch for the update
        # info signals
        global updateInfoDone, updateInfo

        if not updateInfoDone:
            # FIXME: this isn't synchronous anymore.  but it should be
            # reasonable enough given the users
            gobject.idle_add(checkUpdates)
            return []

        return updateInfo

def shutDown():
    sys.exit(0)

def restart():
    os.chdir(initial_directory)
    os.execve(sys.argv[0], sys.argv, os.environ)

def checkHelperStatus():
    global helperProcess
    if helperProcess.poll() is not None:
        helperProcess = None
        return False
    return True

def checkUpdates():
    global helperProcess
    if helperProcess is not None:
        print >> sys.stderr, "Helper process already running"
        return
    helperProcess = subprocess.Popen(["./yum-updatesd-helper", "-c"],
                                     close_fds = True)
    gobject.timeout_add(10 * 1000, checkHelperStatus)

def add_update(*args):
    global updateInfo, updateInfoDone
    if updateInfoDone:
        updateInfo = []
        updateInfoDone = False
    updateInfo.append((args[0][0], args[0][1]))

def updates_done(num):
    global updateInfoDone, updateInfo
    # if we received all the updates, we're good.  otherwise, we need to
    # clear the info out
    if int(num) != len(updateInfo):
        updateInfo = []
    else:
        updateInfoDone = True

def main(options = None):
    if options is None:
        parser = OptionParser()
        parser.add_option("-f", "--no-fork", action="store_true", default=False, dest="nofork")
        parser.add_option("-r", "--remote-shutdown", action="store_true", default=False, dest="remoteshutdown")    
        (options, args) = parser.parse_args()

        if not options.nofork:
            if os.fork():
                sys.exit()
            fd = os.open("/dev/null", os.O_RDWR)
            os.dup2(fd, 0)
            os.dup2(fd, 1)
            os.dup2(fd, 2)
            os.close(fd)

    syslog.openlog("yum-updatesd", 0, syslog.LOG_DAEMON)

    opts = yumdconfig.read_config()

    if opts.dbus_listener:
        bus = dbus.SystemBus()
        name = dbus.service.BusName("edu.duke.linux.yum", bus=bus)
        YumDbusListener(name, allowshutdown = options.remoteshutdown)

        bus.add_signal_receiver(add_update, "UpdateInfoSignal", dbus_interface="edu.duke.linux.yum")
        bus.add_signal_receiver(updates_done, "UpdatesAvailableSignal", dbus_interface="edu.duke.linux.yum")        
    
    run_interval_ms = opts.run_interval * 1000 # needs to be in ms
    gobject.timeout_add(run_interval_ms, checkUpdates)

    mainloop = gobject.MainLoop()
    mainloop.run()


if __name__ == "__main__":
    main()
