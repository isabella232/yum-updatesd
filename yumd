#!/usr/bin/python -tt
#
# Proof of concept yumd implementation
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of version 2 of the GNU General Public License
# as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#
# Copyright 2007 Red Hat, Inc.
# Jeremy Katz <katzj@redhat.com>
#
# since it takes me time everytime to figure this out again, here's how to
# queue a check with dbus-send.  adjust appropriately for other methods
# $ dbus-send --system --print-reply --type=method_call \
#   --dest=edu.duke.linux.yum /Updatesd edu.duke.linux.yum.CheckNow

import os, sys
import syslog
import subprocess
import time

from optparse import OptionParser

import dbus
import dbus.service
import dbus.glib
import gobject

import gamin

sys.path.append('/usr/share/yum-updatesd')
import yumdconfig

updateInfoDone = False
updateInfo = []
helperProcess = None

class YumDbusListener(dbus.service.Object):
    def __init__(self, bus_name, object_path='/Updatesd',
                 allowshutdown = False, config = None):
        dbus.service.Object.__init__(self, bus_name, object_path)
        self.allowshutdown = allowshutdown
        self.yumdconfig = config

    def doCheck(self):
        checkUpdates(self.yumdconfig)
        return False

    @dbus.service.method("edu.duke.linux.yum", in_signature="")
    def CheckNow(self):
        # make updating checking asynchronous since we discover whether
        # or not there are updates via a callback signal anyway
        gobject.idle_add(self.doCheck)
        return "check queued"

    @dbus.service.method("edu.duke.linux.yum", in_signature="")
    def ShutDown(self):
        if not self.allowshutdown:
            return False
        
        # we have to do this in a callback so that it doesn't get
        # sent back to the caller
        gobject.idle_add(shutDown)
        return True

    @dbus.service.method("edu.duke.linux.yum", in_signature="", out_signature="a(a{ss}a{ss})")
    def GetUpdateInfo(self):
        # FIXME: this call is deprecated.  things should watch for the update
        # info signals
        global updateInfoDone, updateInfo

        if not updateInfoDone:
            # FIXME: this isn't synchronous anymore.  but it should be
            # reasonable enough given the users
            gobject.idle_add(self.doCheck)
            return []

        return updateInfo

def shutDown():
    sys.exit(0)

def restart():
    os.chdir(initial_directory)
    os.execve(sys.argv[0], sys.argv, os.environ)

def checkHelperStatus():
    global helperProcess
    if helperProcess.poll() is not None:
        helperProcess = None
        return False
    return True

def checkUpdates(opts):
    global helperProcess
    if helperProcess is not None:
        print >> sys.stderr, "Helper process already running"
        return True
    args = ["./yum-updatesd-helper", "--check"]
    if opts.do_download:
        args.append("--download")
    if opts.do_download_deps:
        args.append("--deps")
    if opts.do_update:
        args.append("--apply")
    if opts.debug:
        args.append("--debug")
    helperProcess = subprocess.Popen(args, close_fds = True)
    gobject.timeout_add(4 * 1000, checkHelperStatus)
    return True

def add_update(update):
    global updateInfo, updateInfoDone
    if updateInfoDone:
        updateInfo = []
        updateInfoDone = False
    updateInfo.append(update)

def updates_done(num):
    global updateInfoDone, updateInfo
    # if we received all the updates, we're good.  otherwise, we need to
    # clear the info out
    if int(num) != len(updateInfo):
        updateInfo = []
    else:
        updateInfoDone = True

def invalidate_cache(*args):
    global updateInfoDone, updateInfo, helperProcess
    if helperProcess is not None:
        return
    updateInfo = []
    updateInfoDone = False
def check_files(mon):
    mon.handle_events()
    return True
def setup_watcher():
    """Sets up gamin-based file watches on things we care about and makes
       it so they get checked every 15 seconds."""
    # add some watches on directories.  check them every 15 seconds
    mon = gamin.WatchMonitor()
    mon.watch_directory("/var/lib/rpm", invalidate_cache)
    map(lambda x: mon.watch_directory("/var/cache/yum/%s" %(x,),
                                      invalidate_cache),
        os.listdir("/var/cache/yum"))
    mon.handle_events()
    gobject.timeout_add(1 * 1000, check_files, mon)
    

def main(options = None):
    if options is None:
        parser = OptionParser()
        parser.add_option("-f", "--no-fork", action="store_true", default=False, dest="nofork")
        parser.add_option("-r", "--remote-shutdown", action="store_true", default=False, dest="remoteshutdown")    
        (options, args) = parser.parse_args()

        if not options.nofork:
            if os.fork():
                sys.exit()
            fd = os.open("/dev/null", os.O_RDWR)
            os.dup2(fd, 0)
            os.dup2(fd, 1)
            os.dup2(fd, 2)
            os.close(fd)

    syslog.openlog("yum-updatesd", 0, syslog.LOG_DAEMON)

    opts = yumdconfig.read_config()

    if opts.dbus_listener:
        bus = dbus.SystemBus()
        name = dbus.service.BusName("edu.duke.linux.yum", bus=bus)
        YumDbusListener(name, allowshutdown = options.remoteshutdown,
                        config = opts)

        bus.add_signal_receiver(add_update, "UpdateInfoSignal", dbus_interface="edu.duke.linux.yum")
        bus.add_signal_receiver(updates_done, "UpdatesAvailableSignal", dbus_interface="edu.duke.linux.yum")        
    
    run_interval_ms = opts.run_interval * 1000 # needs to be in ms
    gobject.timeout_add(run_interval_ms, checkUpdates, opts)

    # set up file watcher when we're idle
    gobject.idle_add(setup_watcher)

    mainloop = gobject.MainLoop()
    mainloop.run()


if __name__ == "__main__":
    main()
